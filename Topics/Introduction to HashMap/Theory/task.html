<div class="step-text">
<p>The <code class="language-java">HashMap</code> class in Java is a member of the Java Collections Framework and is implemented as a <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a hash table is an implementation of the Map interface that provides fast access to its elements. | It is represented by the HashMap class. Internally, a hash table is organized as an array of buckets, where each bucket is a linked list. Each bucket can hold multiple key-value pairs that have the same hash code. When a key-value pair is added to a hash table, a hash function is applied to the key to determine the index of the bucket where the pair should be stored. If there are no collisions, the time complexity of basic operations such as insertion, retrieval, deletion, and search is constant, i.e., O(1). However, as the table fills up, collisions increase, leading to more table look-ups and lower performance, which can degrade to O(n). To prevent this, the load factor is used to trigger a resizing of the table.">hash table</a>. This means that it stores data in <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a key-value pair is a data structure that stores a unique key and a value associated with that key. | It is a fundamental part of the Map interface, which is a collection of such key-value pairs. The key is similar to an index in an array, and the value is the data that is retrieved when the key is used to access it. Key-value pairs are useful in situations where you need to store and retrieve data using a unique identifier. For example, in a phone book, the unique identifier (key) is the name of the contact, and the value associated with that key is the phone number.">key-value pairs</a>, where each key is unique and is used to retrieve the corresponding value. The basic operations of insertion, retrieval and deletion are performed in an average time of O(1), which makes the <code class="language-java">HashMap</code> a very efficient <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a data structure is a collection of elements that are grouped together in a specific way to allow for efficient storage, retrieval, and manipulation of data. | They are represented by different classes from the Java Standard Library and can be generic or non-generic. Data structures can be more sophisticated and flexible than arrays as they are resizable, allowing you to add any number of elements to a collection. Additionally, collections provide a rich set of methods that are already implemented for you, making it easier to perform common operations. Different types of collections have different internal storage structures, so you can choose a collection type that best matches your problem and optimizes your most frequent operations.">data structure</a> for many types of applications.</p>
<p>This allows the execution of <code class="language-java">get()</code> and <code class="language-java">put()</code> methods to remain constant even for large sets. You should remember that <code class="language-java">HashMap</code> does not guarantee the order of its elements â€” the order in which the elements are added may or may not be same.</p>
<h5 id="how-to-create-a-hashmap">How to create a HashMap</h5>
<p>First, you need to import the <code class="language-java">HashMap</code> package in your Java program:</p>
<pre><code class="language-java">import java.util.HashMap;</code></pre>
<p>Then, at the <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a declaration is a statement that introduces a variable, method, or class into the program. | It specifies the type of the entity being declared, its name, and other relevant information such as access modifiers, return type (for methods), and initial values (for variables). For example, the declaration of a method may include its name, return type, access modifier, and parameter list. Declarations are essential for Java to understand the structure and behavior of the program. Incorrect declarations can lead to compilation errors. Java 10 introduced type inference, which allows developers to use the var keyword instead of a specific type, and the type is automatically inferred based on the assigned value.">declaration</a> point inside the method you need to declare it as follow:</p>
<pre><code class="language-java">HashMap&lt;K, V&gt; map = new HashMap&lt;&gt;();</code></pre>
<p>Here, K and V are types of key and value.</p>
<p></p>
<div class="alert alert-primary"><p> <a href="https://hyperskill.org/learn/step/3492" rel="noopener noreferrer nofollow" target="_blank">Learn more about generics</a></p></div>
<p></p>
<h5 id="hashmap-methods">HashMap methods</h5>
<ul><li><p><code class="language-java">get(K)</code>: returns the value associated with the given key, or null if the key is not present in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
myMap.put("banana", 3);
int appleCount = myMap.get("apple"); // appleCount will be 5
</code></pre>
<ul><li><p><code class="language-java">getOrDefault(K,V)</code>: returns the value associated with the given key, or the <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a default value is a value that is automatically assigned to a variable, field, or array element if no explicit initial value is provided. | For example, an array of a primitive type is initialized with default values. Variables of type boolean are initialized to false, while numeric types are initialized to zero. For object reference types, the default value is null. When creating an object of a class, if no constructor is defined, the compiler automatically provides a default no-argument constructor that initializes all fields with their default values. However, if a specific constructor is defined, the default constructor will not be created.">default value</a> if the key is not present in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
int bananaCount = myMap.getOrDefault("banana", 0); // bananaCount will be 0
</code></pre>
<ul><li><p><code class="language-java">put(K,V)</code>: inserts the specified key-value pair into the map. If the key already exists, the existing value is replaced with the new one. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
myMap.put("apple", 7); // replaces the existing value of 5 with 7 for the key "apple"
</code></pre>
<ul><li><p><code class="language-java">remove(K)</code>: removes the key-value pair associated with the given key from the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
myMap.put("banana", 3);
myMap.remove("apple"); // removes the key-value pair associated with the key "apple"
</code></pre>
<ul><li><p><code class="language-java">size()</code>: returns the number of key-value pairs in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
myMap.put("banana", 3);
int mapSize = myMap.size(); // mapSize will be 2
</code></pre>
<ul><li><p><code class="language-java">containsKey(K)</code>: returns <code class="language-java">true</code> if the map contains the specified key, <code class="language-java">false</code> otherwise. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
boolean hasApple = myMap.containsKey("apple"); // hasApple will be true
</code></pre>
<ul><li><p><code class="language-java">containsValue(V)</code>: returns <code class="language-java">true</code> if the map contains the specified value, <code class="language-java">false</code> otherwise. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;();
myMap.put("apple", 5);
myMap.put("banana", 3);
boolean hasValue3 = myMap.containsValue(3); // hasValue3 will be true
</code></pre>
<ul><li><p><code class="language-java">keySet()</code>: returns a set view of the keys contained in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);

// Print all keys
System.out.println("Keys: " + map.keySet()); 
// Output: Keys: [apple, banana, orange]</code></pre>
<ul><li><p><code class="language-java">values()</code>: returns a collection view of the values contained in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);

// Print all values
System.out.println("Values: " + map.values());
// Output: Values: [1, 2, 3]</code></pre>
<ul><li><p><code class="language-java">entrySet()</code>: returns a set view of the mappings contained in the map. For example:</p></li></ul>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);

// Print all key-value pairs
System.out.println("Entries: " + map.entrySet());
// Output: Entries: [apple=1, banana=2, orange=3]
</code></pre>
<h5 id="limitations">Limitations</h5>
<p>Although <code class="language-java">HashMap</code> is a useful data structure for handling key-value storage, it still has several drawbacks:</p>
<ul><li><p><code class="language-java">HashMap</code> keys must be distinct; if you attempt to insert a key with the same value more than once, the previous value will be replaced. <code class="language-java">HashMap</code> provides many methods of O(1) time complexity, but <code class="language-java">containsValue(V)</code> has the O(n) time complexity.</p></li><li><p>The order of item insertion of the items is not preserved by <code class="language-java">HashMap</code>.</p></li><li><p>Standard <code class="language-java">HashMap</code> key classes include String, Character, Integer, Long, and Boolean. When using <a class="theory-lookup not-relevant" href="/learn/step/25732" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a custom class is a user-defined class that you create to serve a specific purpose in your program. | It allows you to define fields (also known as variables or data members) and methods that are tailored to your needs. Fields hold the current state of an instance of the class, and their values can vary for different instances. Custom classes can be used to create objects, assign values to their fields, and use those objects in your program.">custom classes</a> as keys, it is important to override the <code class="language-java">equals()</code> and <code class="language-java">hashCode()</code> methods correctly to ensure proper behavior. If you don't do it, it may result in losing elements from the map, or in poor performance due to collisions in the hash table.</p></li></ul>
<p></p>
<div class="alert alert-primary"><p><a href="https://hyperskill.org/learn/step/19587" rel="noopener noreferrer nofollow" target="_blank">You can learn more about overloading hashCode() and equals() here.</a></p></div>
<p></p>
<h5 id="conclusion">Conclusion</h5>
<p>The <code class="language-java">HashMap</code> class in Java is a powerful and efficient data structure for implementing key-value storage. It provides a wide range of methods for working with data, including insertion, retrieval, deletion, and querying. The basic operations have an average time complexity of O(1), making it suitable for use in many types of applications. However, when using custom classes as keys, it is important to override the <code class="language-java">equals()</code> and <code class="language-java">hashCode()</code> methods correctly to ensure proper behavior. Overall, <code class="language-java">HashMap</code> is a great choice for many use cases where fast key-value storage is required.</p>
</div>